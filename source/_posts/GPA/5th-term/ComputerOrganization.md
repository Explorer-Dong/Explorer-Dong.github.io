---
title: ComputerOrganization
categories:
  - GPA
  - 5th-term
category_bar: true
mermaid: true
---

## 计算机组成原理

## 前言

学科地位：

| 主讲教师 | 学分配额 | 学科类别 |
| :------: | :------: | :------: |
|  闫文珠  |   3.5    |  自发课  |

成绩组成：

| 作业+实验 | 期末 |
| :-------: | :--: |
|    50%    | 50%  |

教材情况：

|    课程名称    |         选用教材         | 版次 |  作者  |     出版社     |      ISBN 号      |
| :------------: | :----------------------: | :--: | :----: | :------------: | :---------------: |
| 计算机组成原理 | 《计算机组成与系统结构》 |  3   | 袁春风 | 清华大学出版社 | 978-7-302-59988-3 |

{% fold light @最基本的硬件普及 %}

- [【硬核科普】从零开始认识主板](https://www.bilibili.com/video/BV1xQ4y1b7JS/)
- [【硬核科普】从零开始认识显卡](https://www.bilibili.com/video/BV1xE421j7Uv/)

**主板（Motherboard）**

- **作用**：主板是所有硬件的连接平台，它连接并协调 CPU、内存、存储设备、显卡、网络设备和其他外部接口。主板上还包含芯片组，负责管理数据传输和设备间的通信。
- **与其他部分的关系**：主板是各个硬件组件的核心枢纽，确保数据能够在各个组件之间高效传输和通信。

![机箱视角中的主板](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202409102038540.png)

![主板的 6 大区域](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202409102039187.png)

**输入/输出设备（I/O Devices）**

- **作用**：输入设备（如键盘、鼠标、触摸屏）用于用户与计算机的交互。输出设备（如显示器、打印机）用于显示计算机的操作结果。网络设备（如网卡、Wi-Fi 模块）则允许电脑连接到网络。
- **与其他部分的关系**：输入设备通过主板将用户的操作传递给 CPU 进行处理，输出设备则从 CPU 或显卡接收处理后的数据进行展示。

![I/O 区域](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202409102039284.png)

**中央处理器（CPU）**

- **作用**：CPU 是电脑的大脑，负责执行计算任务和指令。它从内存中读取指令，进行运算，然后将结果写回内存。现代 CPU 具有多个核心，可以并行处理多项任务，提高计算效率。
- **与其他部分的关系**：CPU 与内存和存储设备密切配合。它从内存中获取数据和指令，然后进行处理，最终将结果写回内存或存储设备。

![CPU 区域](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202409102040689.png)

**内存（RAM）**

- **作用**：内存是计算机中的临时存储器，用于存储当前运行的程序和数据。它的访问速度极快，但数据在断电后会丢失。内存用于支持 CPU 的高速操作。
- **与其他部分的关系**：内存是 CPU 执行任务时的工作区域，存储从存储设备（如硬盘）中读取的数据和指令。内存的数据会在需要时被写回到存储设备中。

![内存区域](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202409102040651.png)

**显卡（GPU）**

- **作用**：显卡负责处理图形计算任务，特别是在图像和视频渲染、游戏以及某些并行计算任务中（如深度学习）。高性能显卡能够加速这些计算任务。
- **与其他部分的关系**：显卡通过主板与 CPU 和内存通信，从内存中读取图形数据，并进行处理，然后将渲染结果输出到显示器。

**存储设备（Storage Devices）**

- **作用**：存储设备如机械硬盘 hard disk (HDD)、固态硬盘 solid state disk (SSD)，用于长期保存数据和程序，即使在电脑断电后数据也不会丢失。SSD 的速度比传统硬盘更快，因此越来越常用。
- **与其他部分的关系**：存储设备保存操作系统、应用程序和用户数据。程序执行时，数据会从存储设备加载到内存中供 CPU 使用。

**网卡（Network Interface Card, NIC）**

- **作用**：网卡是计算机与网络之间的桥梁，负责处理计算机与网络间的数据通信。它将计算机的数据转换为网络信号，以太网网卡通过有线或无线方式连接局域网（LAN）或互联网。
- **与其他部分的关系**：网卡通过主板与南桥芯片组或 PCIe 总线连接，接收来自 CPU 的数据，经过处理后通过网络接口发送到外部网络。同时，它也接收来自网络的数据，传递给 CPU 进行处理，确保计算机能够与其他网络设备进行通信。

![扩展区域](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202409102040086.png)

**南桥芯片组（Southbridge）**

- **作用**：南桥芯片组是主板上的一个重要芯片，为了避免过多的模块与 CPU 直连导致主板排线困难以及布局问题，产生了南桥芯片组用于负责管理较慢的外围设备的连接和数据传输。包括 USB 接口、SATA 接口、网络接口、音频设备和其他 I/O 设备。南桥还处理 BIOS、系统时钟、硬盘和光驱的控制。
- **与其他部分的关系**：南桥通过主板与 CPU 和北桥芯片组（或直接与 CPU）连接，接收来自 CPU 的指令，并将其转化为外设可以理解的信号。它还通过 I/O 总线连接各种外设，确保数据在外围设备与系统之间顺畅传输。

![南桥芯片组区域](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202409102040366.png)

**BIOS（Basic Input/Output System）**

- **作用**：BIOS 是主板的固件程序，它存储在主板的 BIOS 芯片里。负责在计算机启动时进行硬件初始化，指导所有的硬件运行，并启动操作系统。
- **与其他部分的关系**：BIOS 在开机时检查并初始化硬件，然后引导操作系统，从而开始系统的工作。

![BIOS 芯片](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202409102040350.png)

{% endfold %}

为什么要学这门课？

> 上上学期学习了《数字逻辑电路》，云里雾里；上学期学习了《计算机系统基础》，继续云里雾里。本学期开始学习《计算机组成原理》？如果用一句话来概括我对数字逻辑电路的理解，大概可以这样说：原来计算机是一个由“门电路”、“导线”和“时钟脉冲”组成的机器。如果用一句话来概括我对计算机系统基础的理解，大概可以这样说：原来计算机所有的活动都是由翻译过来的 01 序列驱动的。
>
> 现在我们让 AI 模仿上面我对课程理解的概括逻辑，用一句话来概括计算机组成原理，ta 是这样回答的：**原来计算机的高效运作是通过硬件架构的精妙设计，将复杂的指令和数据流转化为有序的电子信号运动来实现的**。
>

会收获什么？

> 对计算机整体有一个宏观的把握，了解 CPU、存储和 I/O 设备的工作逻辑，尤其要熟悉单核 CPU 的工作逻辑。最后能够利用 verilog 硬件描述语言从逻辑上实现一个单核 CPU。
>

注：

> **本书 ISA 采用 MIPS 指令系统**。之前学习的 [《计算机系统基础》](https://blog.dwj601.cn/GPA/4th-term/SysBasic/#3-2-IA-32-指令系统概述) 中 ISA 采用的是 IA-32 指令系统，也就是大名鼎鼎的 x86-64 指令系统的前身。
>
> 为了形式化地描述 CPU 的运行逻辑，需要使用寄存器传送级 (register transfer level, 简称 RTL) 语言。**本书 RTL 语言有以下规定**：R [r] 表示通用寄存器 r 的内容，M [addr] 表示存储单元 addr 的内容；M [R[r]] 表示寄存器 r 的内容所指存储单元的内容；PC 表示 PC 的内容，M [PC] 表示 PC 所指存储单元的内容；SEXT [imm] 表示对 imm 进行符号扩展，ZEXT [imm] 表示对 imm 进行零扩展；传送方向用 $\leftarrow$ 表示，即传送源在右，传送目的在左。

## 绪论

### 1 计算机系统概述

注：本章与《计算机系统基础》的第 1 章重复，详见 <https://blog.dwj601.cn/GPA/4th-term/SysBasic/#第1章-计算机系统概述>

主要掌握 **冯诺依曼状态机** 和 **计算机性能度量** 两个知识点。

### 2 数据的机器级表示

注：本章与《计算机系统基础》的第 2 章重复，详见 <https://blog.dwj601.cn/GPA/4th-term/SysBasic/#第2章-数据的机器级表示与处理>

主要掌握 **数值/非数值数据的表示**、**数据宽度**、**存储对齐** 和 **纠/检错** 四个知识点。

数据的纠错/检错见 7.4 节。

## CPU

### 3 运算方法和运算部件

本章我们讲讲 CPU 中的 **算数逻辑单元（Arithmetic and Logic Unit，简称 ALU）**。ALU 在计算机中的地位大致如下图所示：

```mermaid
graph RL
    实现功能
    执行程序
    机器指令
    subgraph ALU
    direction RL
    算数运算逻辑
    subgraph 运算部件
    direction LR
    加法器
    移位器
    end
    end
    
    运算部件 -->|硬件支持| 算数运算逻辑
    ALU --> 机器指令
    机器指令 --> 执行程序
    执行程序 --> 实现功能
```

也就有了这样的学习路线：涉及运算的机器指令（MIPS 指令系统） $\to$ 运算部件支持（逻辑电路图） $\to$ 算数运算逻辑（算法设计）

#### 3.1 涉及运算的机器指令

**都有哪些涉及运算的机器指令**？机器指令的种类有很多，我们在计算机系统基础中已经学习到了比如：数据传输指令、控制指令、跳转指令等等。由于本章讲解的是算数运算，因此我们主要学习涉及到运算的机器指令。我们将所有涉及到运算的机器指令抽丝剥茧，凝练出了以下共 11 条指令：

![11 条涉及运算指令的 RTL 描述](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202409252041301.png)

![11 条涉及运算指令的 RTL 描述 - 续](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202409252041551.png)

不难发现，上述 11 种除了最后一个跳转指令，其余的 10 条运算指令只有 3 大类：加减法、按位或、小于置 1。

#### 3.2 运算部件支持

**有了上述的程序运算需求，如何设计出对应的硬件来支持呢？CPU 中的 ALU 单元就是负责运算的部件**。ALU 内部的逻辑结构如下图所示，其输入有两个运算数 A 和 B 以及一个控制输入 ALUctr：

![ALU 实现](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202409250813229.png)

ALUctr 有 4 个控制信号，下面借书中原文分别解释 4 个控制信号对应的逻辑：

> SUBctr 用来控制 ALU 执行加法还是减法运算。当 SUBctr = 1 时，做减法；当 SUBctr = 0 时，做加法。
>
> OPctr 用来控制选择哪种运算的结果作为 Result 输出。因为所实现的 11 条指令中只可能有加/减、按位或、小于置 1 这 3 大类运算，所以 OPctr 有两位。
>
> OVctr 用来控制是否要进行溢出判断。当 OVctr = 1 时，进行溢出判断，此时，若结果发生溢出，则溢出标志 Overflow 为 1，当 OVctr = 0 时，无须溢出判断，此时，即使结果发生溢出，溢出标志 Overflow 也不为 1。
>
> SIGctr 信号控制 ALU 是执行「带符号整数比较小于置 1」还是执行「无符号数比较小于置 1」的功能。当 SIGctr = 0，执行「无符号数比较小于置 1」的功能；当 SIGctr = 1 时，执行「带符号整数比较小于置 1」的功能。

完美实现了所需的 3 大类运算逻辑。

**ALU 是如何控制以精准实现上述 11 条指令的？本质上就是通过 ALUctr 来实现运算控制的**。除了最后一个跳转，难道 10 个指令就一定需要 $\lceil \log_2(10) \rceil =4$ 位进行信号选择控制吗？并不是，其中一些虽然功能不同，但是运算逻辑相同：

- 指令 addiu、lw、sw 和 beq 转移目标地址计算的 ALU 控制信号取值一样，都是进行加法运算并不判溢出，记为 addu 操作.
- 指令 subu 和 beq 判 0 操作的 ALU 控制信号可看成一样，都做减法运算并不判溢出，记为 subu 操作。

下表详细解释了每一条指令的运算类型与 ALUctr 取值之间的关系：

![运算类型与 ALUctr 取值之间的关系](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202409261336957.png)

因此，这 11 条指令可以归纳为 7 种操作：addu、add、or、subu、sub、sltu、slt，也就是说 ALUctr 只需要 $\lceil \log_2(7) \rceil =3$ 个选择控制位！如下表所示，列出了 ALUctr 的选择控制逻辑：

![ALUctr 的选择控制逻辑](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202409261337035.png)

**为什么可以这样控制**？

加减运算控制（SUBctr）：很显然，加法（SUBctr = 0），减法（SUBctr = 1）。

输出内容控制（OPctr）：很显然， 3 大类运算就对应 3 个取值。

溢出判断控制（OVctr）：很显然，有符号运算需要溢出判断，其他运算都不需要。

小于置一控制（SIGctr）：这个逻辑比较有意思。为什么无符号数比大小时 `Less = Carry ^ SUBctr`；有符号数比大小时 `Less = Sign ^ Overflow` 呢？首先我们知道，比大小的本质是使用加法器做减法运算，那么 $A-B=A+B_{\text{补}}=A+(\sim B +1)$。

- 对于无符号数的比大小逻辑。由于是减法，SUBctr 一定是 1，因此此时的输出其实可以进一步归纳为 `Less = Carry ^ 1 = !Carry`。也就是说我们只需要分析加法运算的进位结果即可，而这就是之前学过的无符号整数加减运算逻辑了。如果 A 严格小于 B，则 B 的补码与 A 相加后不会产生进位，此时 `!Carry = !0 = 1` 表示 $A<B$；如果 $A\ge B$，则 B 的补码与 A 相加后就会超过无符号整数表示的范围产生进位，此时 `!Carry = !1 = 0` 表示 $A \ge B$。很巧妙的逻辑。
- 对于有符号数的比大小逻辑。
    - 如果运算没有溢出，即 `Overflow=0`，此时 A 与 B 的正负一定相同。A 与 B 的比大小结果可以直接根据加法器运算结果的符号位来确定。如果运算结果是负的，即 `Sign=1`，那么显然 $A<B$；反之如果运算结果是正的，即 `Sign=0`，那么显然 $A\ge B$。
    - 如果运算发生溢出，即 `Overflow=1`，此时 A 与 B 的正负一定不同。但我们不知道谁正谁负，根据有符号整数加减运算的溢出符号判定逻辑可知：
        - 若 A 为正数 B 为负数。溢出发生时运算结果一定是负数（正溢出），即 `Sign=1`，此时 `Less = Sign ^ OverFlow = 0`，即 $A \ge B$。
        - 若 A 为负数 B 为正数，溢出发生时运算结果一定是正数（负溢出），即 `Sign=0`，此时 `Less = Sign ^ OverFlow = 1`，即 $A< B$。

#### 3.3 算数运算逻辑

程序的运算需求有了（算数运算），能进行基本运算的硬件也设计出来了（ALU）。如何利用已有的运算部件来巧妙地设计算法以高效地实现我们常见的数学运算呢？让我们一探究竟！

##### 3.3.1 整数加减运算

不重复造轮子，见上学期记的笔记：<https://blog.dwj601.cn/GPA/4th-term/SysBasic/#2-7-4-整数加减运算>

##### 3.3.2 原码乘法运算

**怎么算的？按照手算乘法的逻辑进行运算**。但是在计算机内部进行了一定的改进，有三点：

1. 并不是全部算完每一步的乘法结果后再一次性累加，而是使用一个 "局部变量" 保存前缀和（部分积）；
2. 由于每一位的乘法结果都是在最高位进行的，因此我们不是对当前的乘法运算结果左移一位，而是将前面计算出的前缀和右移一位；
3. 由于单步乘法运算时只有 0 和 1，显然若当前为 0 则对答案的贡献也为 0，因此当乘法位为 0 时只需要前缀和右移一位即可，而不需要执行相加操作。

{% fold light @推导过程 %}

其实算法过程很简单，就是模拟了乘法运算的过程，这里就不罗列了。只不过其中有一些关于运算部件的巧妙利用。比如将每次部分积右移后多出来的一位存放到 Y 中，反正 Y 右移后的最后一位已经没用并且舍弃掉了，前面空出来的一位正好就用来存储部分积的最后一位。

我们将二进制位从低到高的下标从 1 开始计数，进位位记作 C，部分积记作 P，乘数位记作 Y，则有这样的递推式：
$$
P_i = (P_{i-1}+Xy_i) \gg 1,\quad P_0 = 0
$$
模拟过程如下：

![算例](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202409291051084.png)

{% endfold %}

**有哪些应用场景？浮点数尾数运算**。在浮点数的尾数运算中，对数值位直接使用原码乘法即可，符号位就是两个乘数的符号位相异或的结果，例如：设 $[x]_\text{原}=0.1110$，$[y]_\text{原}=1.1101$，计算 $[x\times y]_\text{原}$，符号位为 $0\oplus 1=1$，数值位为 $[x]_\text{原} \times [y]_\text{原}$，即 $1110 \times 1101$ 的原码乘法运算结果 $10110110$。

**可以优化吗？分块思想**。由于是逐位运算，因此我们需要进行 $n$ 次相乘再相加的操作，时间复杂度为 $O(n)$。现有的优化方案就是逐 $k$ 位运算，那么时间复杂度就可以优化为 $O(\frac{n}{k})$。

##### 3.3.3 补码乘法运算

**怎么算的**？如何在已知 $[X]_{\text{补}}$ 和 $[Y]_{\text{补}}$ 的情况下，计算 $[X\times Y]_{\text{补}}$？由于 $[X\times Y]_{\text{补}} \ne [X]_{\text{补}} \times [Y]_{\text{补}}$，因此补码乘法不能直接使用原码乘法的算法，需要我们重新设计运算方法，这里引入 Booth 算法。

{% fold light @推导过程 %}

布斯算法的本质是将符号位与数值位一起运算，也就是对有符号数的一次性运算算法。如下推导：

![推导](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202409291113812.png)

进而可以得到关于「真值」的部分积递推公式：
$$
P_{i} = [P_{i-1} + (y_{i-2}-y_{i-1})X] \gg 1
$$
于是可以得到关于「补码」的部分积递推公式：
$$
\begin{aligned}
[P_{i}] _{\text{补}} &= [P_{i-1} + (y_{i-2}-y_{i-1})X]_{\text{补}} \gg 1 \\
&= [P_{i-1}] _{\text{补}} \gg 1 + [(y_{i-2}-y_{i-1})X]_{\text{补}} \gg 1
\end{aligned}
$$
显然的 $y_{i-2}-y_{i-1}$ 只有 $-1,0,1$ 共 3 种情况，因此我们只需要知道 $-[X]_{\text{补}}$ 和 $[X]_{\text{补}}$ 即可利用移位和加法快速运算。例如下面的算例：

![算例](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202409291137346.png)

{% endfold %}

**有哪些应用场景？很多**。由于计算机中的数据都是以补码形式存储，因此补码乘法的使用场景更加广泛。

**可以优化吗？分块思想**。与原码乘法的优化方案类似。

### 4 指令系统

### 5 中央处理器

### 6 指令流水线

## 存储

### 7 存储器

当机器有了记忆，就可以不用人为干预而自动运行，从而真正意义上实现了自动化的流程。本章主要学习计算机中的存储器件、存储策略以及数据交互逻辑。

现代计算机中有很多类型的存储器，核心功能都是存储数据，那为什么不统一成一种存储器呢？根本原因是 CPU 的计算速度远大于从存储器中访存数据的速度，因此我们不得不设计出可以匹配 CPU 计算速度的存储器结构。但这样的存储器造价极高并且存储量很小，因此我们只能退而求其次，从而诞生了现代计算机中的层次存储结构。从 CPU 开始依次为：**寄存器 (Register)**、**缓存 (Cache)**、**内存 (Main Memory)** 和 **外存 (Secondary Memory)**。这些存储器的访存速度逐渐降低。本章也将按照这样的顺序分别讲解相应的概念。最后会补充介绍一下存储器中的 **虚拟存储** 理念以及 **数据校验** 策略。

#### 7.1 缓存

缓存采用的随机存取存储器是 SRAM，即静态随机存取存储器。由于其速度快容量小且造价很高，因此适合做 cache 工作。SRAM 存储高低电平的方式是触发器。

##### 7.1.1 为什么会有缓存

为什么会有缓存？这是基于什么特性才产生的？程序的局部性。

**程序为什么具有局部性**？从高级语言的逻辑进行理解不难发现，数据的重复访问往往集中在一个程序段中，而对应的指令和数据是连续存储的，因此程序在内存中运行时具有局部性。不断执行的某些指令和不断访问的某些数据就可以存入缓存中。这里根据局部性再衍生出「空间局部性」和「时间局部性」两个概念。

- 空间局部性简单来讲就是某些指令或数据「存储顺序和访问顺序的差异」。差异越小，空间局部性就越好。
- 时间局部性简单来讲就是某些指令或数据「短时间内重复访问的情况」。重复访问的越多，时间局部性就越好。

##### 7.1.2 工作逻辑

**分块思想**。cache 一般被组装在 CPU 内部，便于和寄存器进行高效的数据交互。与此同时，设计者将 cache 和内存进行了划分，使得两者被划分为由相同大小存储空间组成的存储器，在 cache 中被称为行 (line) 或槽 (slot)，在内存中被称为块 (block)。为了知道 cache 中每一个槽中是否有有效缓存，设计者对 cache 中的每一个槽设定了一个有效位来区分是否存储了有效缓存数据。下图给出了 CPU 读取内存信息的流程：

![CPU 读取内存信息的流程](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202410160933739.png)

**示例解释**。有了上述对 cache 和内存「分块」的思想，也就可以解释从大一一开始就提到的，下面两个程序执行时间天壤之别的原因：

```cpp
int a[M][N];

// 更快
int s = 0;
for (int i = 0; i < M; i++) {
    for (int j = 0; j < N; j++) {
        s += A[i][j];
    }
}

// 很慢
int t = 0;
for (int j = 0; j < N; j++) {
    for (int i = 0; i < M; i++) {
        s += A[i][j];
    }
}
```

我们知道上述两个程序段的指令数量很少，就忽略指令的局部性带来的差异，仅仅考虑数据的局部性差异。由于对数据进行访问时，不同的数据仅仅是地址的差异，而每一个数据的地址都是用加法器一步运算出来的，按道理并不会有任何时间开销的差异。那这几十倍的时间开销差异从何而来？其实就是缓存的功劳。

**值得一提的是**。如果数据/指令的大小比一个「槽」或「块」还要小，那就利用不上缓存机制了。

**缓存是物理存在但逻辑透明的**。从上述讨论可以发现，缓存机制对于代码编写者和编译器都是 **透明** 的存在，是从物理层面上对程序进行的优化。

**缓存 - 内存平均访问时间**。我们定义「缓存 - 内存平均访问时间」为 $P \times T_c + (1 - P) \times (T_c + T_m)$。其中 $P$ 表示命中的概率，$T_c$ 表示访问缓存的平均时间，$T_m$ 表示访问内存的平均时间。

##### 7.1.3 映射策略

cache 和内存的映射关系是什么？接下来我们深入探讨「直接映射、全相联映射和组相联映射」三种映射策略。

**直接映射**

![分块示意图 | 直接映射](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202410231108282.png)

访存机制。地址译码器接收到 CPU 发送的地址后将其解析为 3 部分，如上图所示从高位到低位分别为：标记、cache 行号、块内地址。前两个部分其实就直接对应了内存中的哪一块，只不过在模映射规则下，可以先通过「cache 行号」的比较结果来判断是否需要继续进行标记匹配。具体的，如果此时 `cache 行号匹配成功 && 标记匹配成功 && cache 的这一行是有效行`，那就算命中了，此时地址译码器就直接返回 cache 中当前地址 A 存储的数据/指令；反之如果 `cache 行号匹配失败 || 标记匹配失败 || cache 的这一行不是有效行`，那就算脱靶，此时就需要到内存找这个地址对应的数据/地址并返回，同时需要把这个地址在所在的块复制一份到 cache 对应的行。

特点。可以理解为模映射，即对内存块编号后模上 cache 的行数进行映射。这种策略的 **优点** 在于可以在一定程度上减少地址的匹配位数。但是越简单的东西 **缺点** 也一定越明显，这种策略很可能造成极端情况发生，即某些被频繁访问的内存块对应到 cache 的行是一致的，这就无法利用上别的闲置的行，并且会导致 cache 对应的行被频繁的替换而且还不能很好的起到缓存作用。

**全相联映射**

![分块示意图 | 全相联映射](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202410231126000.png)

访存机制。存储的信息是完全一样的，此时的地址被划分为了 2 个部分，从高位到低位分别为：标记和块内地址。地址译码器根据 CPU 发出来的地址进行解析之后，遍历 cache 中所有的行进行标记匹配。

特点。内存中的每一个块可以缓存到任意一个 cache 行中。显然的全相联映射的 **优点** 在于直接解决了模映射策略中不断遇到模数相等需要不断替换的极端情况。**缺点** 在于丢失了模映射的匹配优势，每一次匹配都需要完全匹配所有的标记。

**组相联映射**

![分块示意图 | 组相联映射](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202410231131574.png)

访存机制。以 N 路组相联为例，其表示 cache 中每一个组含有 N 个 cache 行，组间进行直接映射，组内全相联映射。地址译码器接收到 CPU 发送的地址后将其解析为 3 部分，从高位到低位分别为：标记、cache 组号和块内地址。首先 $O(1)$ 计算出匹配的 cache 组号，然后遍历当前组中所有的行进行标记匹配和标志位判断。

特点。综合了直接映射和全相联映射的 **优点**，既可以避免频繁替换的极端情况，也可以加快地址的匹配速度。

##### 7.1.4 替换算法

不难发现，在上述三种映射策略中，除了模映射是一一对应直接替换，另外两种映射策略由于存在随机性，需要考虑替换哪一行。我们介绍先进先出 (FIFO) 和 最近最少使用 (LRU) 两种替换算法。

**先进先出 (First In First Out, FIFO)**

算法比较简单，就是一个队列算法。当然实际技巧是，每次标记队头缓存行，一旦脱靶就替换队头对应的缓存行，然后将下一行标记为队头即可。

**最近最少使用 (Least Recently Used)**

算法也比较简单。实现技巧在于给每一个 cache 行一个计数器，从而找到最近最久未被使用的 cache 行进行替换。

{% fold light @综合例题 %}

问：假定计算机系统有一个容量为 $32K\times 16$ 位的主存，主存按字节编址，每字节 $16$ 位。且有一个数据区容量为 $4K$ 字节的 $4$ 路组相联 Cache，采用 LRU 替换算法。主存和 Cache 之间数据交换块的大小为 $64$ 字。假定 Cache 开始为空，处理器顺序地从存储单元 $0,1,\cdots,4351$ 中取数，一共重复 $10$ 次。设 Cache 比主存快 $10$ 倍。试分析 Cache 的结构和主存地址的划分，并说明采用 Cache 后速度提高了多少？

答：

- Cache 的结构。由于 cache 的数据区容量为 4K，根据传输的数据块大小 64 字可以很容易算出 cache 一共有 4K/64 = 64 行。由于是 4 路组相联，因此 cache 一共有 16 组，每组 4 行。

- 主存地址的划分。根据主存总容量 32K，以及传输的数据块大小 64 字可以很容易算出主存一共有 32K/64 = 512 块。每一个块对应到 cache 16 个组中的一个，因此主存结构如下：

    | 标记 | cache 组号 | 块内地址 |
    | :--: | :--------: | :------: |
    | 5 位  |    4 位     |   6 位    |

- 速度提升。由于取数是对应 $[0,4151]$ 共 $4152/64=68$ 块，因此本质上只访问了内存中的 $68$ 块数据。初始的 $64$ 块数据需要全部访问内存获取，最后 $4$ 块由于需要替换也需要从内存获取。因此第一轮需要访问内存 $68$ 次。不难发现，在 LRU 算法下，后续的 $9$ 轮都是在对前四组中的 cache 行替换 $5$ 次，因此后续的 $9$ 轮每一轮都需要从内存访问 $20$ 次。那么命中率 $P$ 为：
    $$
    P=\frac{43520-68-20\times 9}{43520}\approx99.43\%
    $$
    速度提升的倍数为：
    $$
    \frac{T_m}{P\times T_c + (1-P)T_m} = \frac{10}{99.43\% \times 1 + (1-99.43\%)\times 10}\approx 9.51
    $$

{% endfold %}

#### 7.2 内存

内存采用的随机存取存储器是 DRAM，即动态随机存取存储器。相比于 SRAM，DRAM 速度较慢但容量更大，因此适合做内存工作。DRAM 存储高低电平的方式是电平，即通过电容的高低电平状态来存储 01 状态。由于 DRAM 的读操作会对高电平进行放电，因此需要定时对 DRAM 的电容进行充电工作，也就是所谓的刷新。

##### 7.2.1 CPU 与内存交互数据的逻辑

![基本框图](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202410112007235.png)

CPU 首先通过「控制线」将读/写信号送到内存，然后分读写两种情况：

1. CPU 需要读数据时。就将需要读取数据的地址通过「地址线」送到内存寻找相应的数据，内存通过「数据线」将数据返回给 CPU。
2. CPU 需要写数据时。就将需要写入数据的地址通过「地址线」送到内存寻找待写入的内存，同时将需要写入的数据通过「数据线」送到内存并写入指定的内存中。

CPU 与 内存的数据的通信分为异步和同步两种：

1. 异步。CPU 从 数据线取数时需要收到内存已经准备好数据的信号。
2. 同步。CPU 从数据线取数无须内存的信号，而是在向内存发出取数信号后，经过确定的时间后就从数据线取数。

##### 7.2.2 地址译码器的工作逻辑

![一维单译码器 VS 二维双译码器](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202410112041997.png)

如果有 $n$ 位地址位，就决定了寻址范围为 $[0,2^n-1]$。不难发现如果是一维单译码，就需要译码器有 $2^n$ 个寻址线。如果是二维双译码，就需要译码器有 $2 \times 2^{n/2}$ 个寻址线。显然当地址位较多时，二维双译码器是更优的。

##### 7.2.3 字/位扩展

扩展分为「字扩展、位扩展和字位同时扩展」三种。扩展逻辑已经在数电中学习过了，具体见 <https://blog.dwj601.cn/GPA/3rd-term/DigitalLogicCircuit/#4-4-2-译码器-数据分配器>

##### 7.2.4 提速策略

多模块存储器、cache (ch7.1)。

#### 7.3 外存

#### 7.4 虚存

#### 7.5 数据校验

数据在信道传送的过程中，可能会因为各种噪声或者硬件原因出现错误，我们有必要进行数据的检错与纠错。本目我们主要介绍数据检错中的「奇偶校验法」策略。其实逻辑很简单，先看数据校验的流程图：

![数据校验流程图](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202409180822743.png)

如上图所示，校验的根本逻辑就是：比对「信源和信宿数据的二进制码」在某种转换规则下的转换代码。而所谓的奇偶校验就是定义了「某种规则」为「比对数据的二进制码中 1 的个数」。即通过判断校验单元（校验位+原始数据）和传输后数据中 1 的个数的奇偶性是否相同，来判断数据传送是否正确，进而达到检错的功能。有两个问题：

1. **这合理吗**？显然不具备绝对正确性。因为奇偶校验的根本逻辑是比对数据传输前后的 1 的数量的奇偶是否。反例有很多：
    - 首先我们不能保证校验码传输前后是否会发生错误。
    - 其次针对校验逻辑，奇偶校验都不能检测出偶数位数据传输错误，并且，如果校验位前后不同则表明数据传输的过程中一定发生了错误，但是不能知道多少位 $(1,3,5,...2n-1)$ 发生了错误，并且也不知道哪几位发生了错误。
2. **怎么计算二进制码中 1 的个数的奇偶性**？很简单，直接把所有的位异或起来即可。

**码距是什么**？所谓码距就是两个二进制代码（码字）中不同位的个数。在奇偶校验的码制下，两个合法码字的最小距离显然是 2。

参考：[什么是奇偶校验原理？奇校验、偶校验、校验位（单比特奇偶校验、两维奇偶校验（矩阵校验或交叉奇偶校验））](https://blog.csdn.net/Dontla/article/details/103627008)

## 设备

### 8 系统互连及输入输出组织

## 并行 *

### 9 并行处理系统 *

不做要求，略。
