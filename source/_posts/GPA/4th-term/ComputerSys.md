---
title: ComputerSys
categories:
  - GPA
  - 4th-term
category_bar: true
---

## 《计算机系统基础》

## 前言

学科地位：

| 主讲教师 | 学分配额 | 学科类别 |
| :------: | :------: | :------: |
|  闫文珠  |   3.5    |  专业课  |

成绩组成：

| 实验（9次） | 平时作业 | 期末（闭卷） |
| :---------: | :------: | :----------: |
|     20%     |   30%    |     50%      |

教材情况：

|    课程名称    |    选用教材    | 版次 |  作者  |     出版社     |      ISBN号       |
| :------------: | :------------: | :--: | :----: | :------------: | :---------------: |
| 计算机系统基础 | 计算机系统基础 |  4   | 袁春风 | 机械工业出版社 | 978-7-111-60489-1 |

学习资源：

- :tv: 视频资源：[袁春风](https://www.icourse163.org/u/mooc1463468641395)

期末考试：

- 简答（类似于作业）
- 计算（类似于作业）
- 综合（尽可能收集老师们的复习资料）

## 第1章 计算机系统概述

### 1.1 计算机基本工作原理 TODO



### 1.2 程序的开发与运行 TODO



### 1.3 计算机系统的层次结构 TODO



### 1.4 计算机系统性能评价 TODO

一个完整的计算机系统由软件和硬件共同组成，而硬件的性能对其起决定性作用，但是硬件的性能检测和评价比较困难。本目介绍综合性测试、评价**硬件性能**的方法。

#### 1.4.1 计算机性能的定义

考量一个计算机性能的基本指标有两个，分别为吞吐率（throughput）和响应时间（response time），下面做出相应的理论解释和自己的理解。

理论定义

- 吞吐率：计算机系统单位时间内完成的工作量。

- 响应时间：计算机系统完成一个作业从提交开始到作业完成所用的时间。

{% fold info @个人理解 + 适合场景 %}

**个人理解**：我们以备份文件为例。**对于一个大文件**，我们希望计算机系统的吞吐率性能足够好，这样处理单文件的能力就会很高。**对于很多的小文件**，吞吐率高没有什么决定性作用，起决定性作用的是响应时间，我们希望响应时间尽可能的短，这样处理大规模小文件集合的时候就会有优势。那么相应的适用场景也就合理了。

**适用场景**：对于多媒体应用场景，就相当于大型文件，此时自然希望吞吐率尽可能的高。对于银行、证券交易业务，就相当于大规模小文件集合，我们希望系统的响应时间尽可能的短，这样就可以在单位时间解决更多的小型业务。当然，两者性能均优异自然是最佳选择，对于一些用户体验很重要的应用，比如 ATM、文件服务、Web 服务 等等，就需要两者性能均优。

{% endfold %}

#### 1.4.2 计算机性能的测试

如果不考虑应用背景而直接比较计算机性能，往往通过**程序的执行时间**来衡量。下附程序的执行时间组成图：

{% fold info @程序的执行时间组成图 %}

![程序的执行时间（用户感受到的）](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202403252043639.png)

{% endfold %}

我们关注的是**用户 CPU 时间**。那么如何计算呢？我们引入三个相关计算量：

1. 时钟周期：一个时钟脉冲信号持续的时间。由于计算机执行官一条指令得过程会被分为不同的小模块进行，因此我们需要控制每一个小模块的执行。于是引入脉冲信号来控制信号的发出、作用时间等。
2. 时钟频率：单位时间内的时钟周期数。即上述时钟周期的倒数。
3. CPI（Cycles Per Instruction）
    - 对于一条指令而言：CPI 指的是一条指令所需的时钟周期数
    - 对于一个程序或一台机器而言：CPI 指的是该程序或机器的指令集中所有指令平均执行所需的时钟周期数

计算**用户 CPU 时间**的公式：

$$
\begin{equation*}
\begin{aligned}
\text{用户 CPU 时间} 
&= \text{程序总时钟周期数} \times \text{时钟周期} \\
&= \text{程序总时钟周期数} \div \text{时钟频率}
\end{aligned}
\end{equation*}
$$
补充说明：

- 显然，用户 CPU 时间与计算机性能成反比
- 上述三个相关计算量是相互制约的，不存在只提升或下降某一个指标

#### 1.4.3 用指令执行速度进行性能评估 TODO



#### 1.4.4 用基准程序进行性能评估 TODO



#### 1.4.5 Amdahl 定律 TODO



### 1.5 本书的主要内容与组织结构

第一章主要介绍：计算机的基本工作原理、计算机系统的基本组成、程序的开发与执行过程、计算机系统的层次结构以及性能评价的基本概念。

第二章主要介绍：各类数据在计算机中的表示与运算。

第三章主要介绍：高级语言中的过程调用和控制语句所对应的汇编指令序列，以及各类数据结构元素的访问所对应的汇编指令。

第四章主页介绍：如何将多个模块链接起来生成一个可执行的目标文件。

## 第2章 数据的机器级表示与处理

{% note info %}

本章主要从四个方面展开，分别为：数值数据的表示、非数值数据的表示、数据的存储、数据的运算。

{% endnote %}

### 2.1 数制和编码 TODO

#### 2.1.1 信息的二进制编码

#### 2.1.2 进位计数制

进制表示

1. 二进制：后缀为 B（即 Binary，如 0110B）
2. 八进制：后缀为 O（即 Octal，如 12673O）
3. 十进制：后缀为 D（即 Decimal，如 291D；可省略，即 291）
4. 十六进制：后缀为 H（即 Hexadecimal，如 3F9H；可以前缀 0x 标记，即 0x3F9）

进制转换

1. R 进制转换为 十进制
2. 十进制转换为 R 进制
3. 二、八、十六进制的相互转换

#### 2.1.3 定点与浮点的表示

#### 2.1.4 定点数的编码表示

1. 原码表示法
2. 补码表示法
    - 模运算：$\text{对一个负数取模} = \text{模} - |\text{负数}|$
    - 补码的定义：$[X]_{\text{补}}=2^n+X$，对于 $n$ 位的运算系统，可以表示补码的数据范围为 $-2^{n-1} \le X < 2^{n-1}$
3. 反码表示法
4. 移码表示法

### 2.2 整数的表示 TODO

#### 2.2.1 无符号整数和带符号整数的表示

无符号整数：所有的二进制位都用来表示数值。比如对于 $n$ 位的二进制数，无符号整数的数值范围为 $[0,2^{n} - 1]$

有符号整数：第一位二进制位必须用来进行正负性表示，后 $n-1$ 位用来表示数值。同样对于 $n$ 位的二进制数，有符号整数的数值范围为 $[-2^{n-1}, 2^{n-1})$

#### 2.2.2 C 语言中的整数及其相互转换

C 语言标准中规定：若运算中同时有无符号和带符号整数，则按无符号整数运算

### 2.3 浮点数的表示 TODO

#### 2.3.1 浮点数的表示范围

#### 2.3.2 浮点数的规格化

#### 2.3.3 IEEE 754 浮点数标准

掌握十进制小数转化为IEEE754的小数表示

![十进制小数转化为IEEE754的小数](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202404081030218.png)

掌握IEEE754小数转化为十进制小数的形式

![IEEE754小数转化为十进制小数](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202404081030753.png)

#### 2.3.4 C 语言中的浮点数类型







### 2.4 十进制数的表示 TODO

#### 2.4.1 用 ASCII 码字符表示

#### 2.4.2 用 BCD 码表示







### 2.5 非数值数据的编码表示 TODO

#### 2.5.1 逻辑值

1 个 二进制数表示 1 个逻辑值。

#### 2.5.2 西文字符

西文字符集的编码是 ACSII 码，一般是 7 位二进制位 $b_6b_5b_4b_3b_2b_1b_0$ 来表示。可能会有第八位 $b_7$，该位往往用来进行奇偶校验。

#### 2.5.3 汉字字符

汉字数量庞大，且是表意形的字符，为了在计算机中表示汉字，我们需要处理三个问题，分别是输入表示、机器表示、输出表示：

1. 汉字的输入码：用于对输入的中文字符进行编码

2. 字符集与汉字内码：用于系统内部的存储、查找、传送等处理

3. 汉字的字模点阵码和轮廓描述：用于显示和打印

概念定义：

  - 图像的基本单位是像素，是真实世界的数字表示

  - 图形的往往是数学或程序算法生成的，是虚构的


### 2.6 数据的宽度和存储

#### 2.6.1 数据的宽度和单位

计算机中数据的**表示宽度**及其单位

- 二进制信息的最小单位：比特（bit）

- 最小寻址单位：字节（Byte），其中 1Byte = 8 bit
- 更大的单位表示：字（word），其中 1 word = 2 bit | 4 bit | 8 bit | 16 bit

计算机中数据的运算、存储、传输的**部件宽度**及其单位

- 数据通路宽度：字长

#### 2.6.2 数据的存储和排列顺序

对于一个 32 bit 的数 `1000 0000 0000 0000 0000 0000 0000 0110` 而言，我们定义：

- 最高有效位（MSB，Most Significant Bit）：上述 32 位数的最左边的一位 `1`

- 最低有效位（LSB，Least Significant Bit）：上述 32 位数的最右边的一位 `0`

- 最高有效字节（MSB，Most Significant Byte）：上述 32 位数的最左边的一字节 `1000 0000`

- 最低有效字节（LSB，Least Significant Byte）：上述 32 位数的最右边的一字节 `0000 0110`

现代计算机都是对字节进行编址方式。由于程序中对每个数据只给定一个地址，那么对于多字节的数据如何根据仅有的一个地址进行 CPU 的内存分配呢？这就是经典的字节排序问题。现在介绍两种内存分配方式：大端方式、小端方式

- 大端方式：最低有效字节存放在最高位

- 小端方式：最低有效字节存放在最低位

- 举例说明：对于机器数 `FFFFFFF6` 而言，下面的表示方式中，左侧为小端存储，右侧为大端存储

    ![左侧为小端存储，右侧为大端存储](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202404081008751.png)

### 2.7 数据的基本运算 TODO

{% note info %}

学完了基本的数据表示以后，让我们开始学习数据的基本运算。高级语言中涉及到的各种运算，都会被编译成底层的算术运算指令和逻辑运算指令实现，本目要介绍的也就是其中的运算逻辑。

{% endnote %}

#### 2.7.1 按位运算和逻辑运算

按位运算

|   \|   |   &    |    ~     |    ^     |
| :----: | :----: | :------: | :------: |
| 按位或 | 按位于 | 按位取反 | 按位异或 |

逻辑运算

|  \|\|  |   &&   |   !    |
| :----: | :----: | :----: |
| 逻辑或 | 逻辑与 | 逻辑非 |

#### 2.7.2 左移运算和右移运算

无符号整数采用**逻辑移位**：

- 左移：高位移出，低位补 0。**如果移出为 1，则溢出**
- 右移：高位补 0，低位移出。

有符号整数采用**算数移位**：

- 左移：高位移出，低位补 0。**如果左移前后符号位不同，则溢出**
- 右移：高位补符号，低位移出。

#### 2.7.3 位扩展运算和位截断运算

扩展操作：在短数向长数转换时

- 有符号整数采用**符号扩展**：前方补符号位
- 无符号整数采用 **0 扩展**：前方补 0

{% fold info @code %}

```cpp
#include <stdio.h>

int main() {
    short int si = -32768;
    unsigned short usi = si;
    int i = si;
    unsigned ui = usi;
    
    printf("si  = \t%hd\t%x\n", si, si);
    printf("usi = \t%hu\t%x\n", usi, usi);
    printf("i   = \t%d\t%x\n", i, i);
    printf("ui  = \t%u\t%x\n", ui, ui);
}
```

上述代码在 32 位大端机器上的输出：

```
si  =   -32768  8000
usi =   32768   8000
i   =   -32768  ffff8000
ui  =   32768   8000
```

分析：

- `si` 和 `usi` 是同一个机器数的不同真值结果，由于数位没有长短的变化，故十六进制表示结果相同
- `i` 是有符号整数的位扩展，采用符号扩展，补充符号位 1，故向前补充了 16 个 1
- `ui` 是无符号数的位扩展，采用 0 扩展，补充 0，故向前补充了 16 个 0

{% endfold %}

截断操作：在长数向短数转换时

- 有符号整数，高位直接丢弃
- 无符号整数，高位直接丢弃

{% fold info @code %}

```cpp
#include <stdio.h>

int main() {
    int i = 32768;
    short si = (short)i;
    int j = si;

    printf("i  = \t%d\t%x\n", i, i);
    printf("si = \t%hd\t%x\n", si, si);
    printf("j  = \t%d\t%x\n", j, j);
}
```

上述代码在 32 位大端机器上的输出：

```
i  =    32768   00008000
si =    -32768  8000
j  =    -32768  ffff8000
```

分析：

- `i` 的真值和机器数很显然
- `si` 的机器数就是将 `i` 的机器数截取了后 16 位的结果，在识别为有符号数以后，得到的真值就是最小的负数 -32768
- `j` 是有符号整数的位扩展运算，补充符号位 1
- 可以发现了**截断错误**，而这种错误编译器一般是不会发现的！

{% endfold %}

#### 2.7.4 整数加减运算

![整数加/减运算部件](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202404081025914.png)

部件解读：对于无符号整数和有符号整数而言，都可采用该运算部件进行运算

- 输入：
    1. 运算数 A：整数 A 的补码 01 序列
    2. 运算数 B：整数 B 的补码 01 序列
    3. 判别数 Sub：`A+B` 时 `Sub=0`，`A-B` 时 `Sub=1`
    
- 输出：
    1. 结果 Sum：表示整数 `A+B` 的计算结果
    
    2. 零标志 ZF：表示 `A+B` 是否为 0
    
    3. 符号标志 SF：表示计算结果 Sum 的最高位二进制值
    
    4. 溢出标志 OF：判断**有符号整数**的相加结果是否溢出。计算方式： 
    
        - 若 A 与 B' 首位同号且与 Sum 的首位不相同，则计算溢出，`OF = 1`
        - 反之则计算未溢出，`OF = 0`
    
    5. 进/借位标志 CF：判断**无符号整数**的相加结果是否溢出。计算方式：
    
        - 对于加法：此时的判别数 `Sub = 0`
    
            - 若有进位，即 `Cout = 1`，则对于当前加法器表示计算溢出，`CF = 1`
            - 若没有进位，即 `Cout = 0`，则没有计算溢出，`CF = 0`
    
        - 对于减法：此时的判别数 `Sub = 1`
    
            - 若有借位，则 `Cout = 0`，则对于当前加法器表示计算结果是负数，即计算溢出，`CF = 1`
            - 若没有借位，则 `Cout = 1`，则对于当前加法器表示计算结果是正数，即计算未溢出，`CF = 0`
    
        - 综上所述：
            $$
            \text{CF} = \text{Sub} \oplus \text{Cout}
            $$

{% fold info @举例说明 %}

对于两个机器数 `x = 1000 0110` 和 `y = 1111 0110`

加法：计算 `x + y`

$$
\begin{aligned}

&\text{MUX}:
\begin{cases}
y' &= y \\
\text{Sub} &= 0
\end{cases}

\\

&\text{Adder}:
\begin{cases}
x: & 1000\ 0110 \\
y'=y: & 1111\ 0110 \\
\text{Sub}: & 0
\end{cases}

\\

&\text{Result}: 1 \ 0111\ 1100

\\

&\text{Signals}:
\begin{cases}
\text{ZF} = 0 \\
\text{SF} = 0 \\
\text{OF} = 1 \\
\text{CF} = 1
\end{cases}

\\

&\text{Real Value}:
\begin{cases}
\text{signed}: &124(134+246-2^8)\\
\text{unsigned}: &124(134+246-2^8)
\end{cases}

\end{aligned}
$$
减法：计算 `x - y`
$$
\begin{aligned}

&\text{MUX}:
\begin{cases}
y' &= \overline{y} \\
\text{Sub} &= 1
\end{cases}

\\

&\text{Adder}:
\begin{cases}
x: & 1000\ 0110 \\
y'=\overline{y}: & 0000\ 1001 \\
\text{Sub}: & 1
\end{cases}

\\

&\text{Result}: 0 \ 1001\ 0000

\\

&\text{Signals}:
\begin{cases}
\text{ZF} = 0 \\
\text{SF} = 0 \\
\text{OF} = 0 \\
\text{CF} = 1
\end{cases}

\\

&\text{Real Value}:
\begin{cases}
\text{signed}: &-112 \\
\text{unsigned}: &144(134-246+2^8)
\end{cases}

\end{aligned}
$$
对于 n=8 的情况而言，数据范围是：
$$
\begin{cases}
\text{signed}: &[-2^{n-1},2^{n-1} - 1] &=& [-128,127] \\
\text{unsigned}: &[0,2^n - 1] &=& [0,255]
\end{cases}
$$
{% endfold %}

#### 2.7.5 整数乘除运算 TODO




#### 2.7.6 常量的乘除运算 TODO



#### 2.7.7 浮点数运算



## 第3章 程序的转换及机器级表示

### 3.1 程序转换概述



### 3.2 IA-32 指令系统概述



### 3.3 IA-32 常用指令类型及其操作



### 3.4 C 语言程序的机器级表示



### 3.5 复杂数据类型的分配和访问



### 3.6 越界访问和缓冲区溢出



### 3.7 兼容 IA-32 的 64 位系统



## 第4章 程序的链接

### 4.1 编译、汇编和静态链接



### 4.2 目标文件格式



### 4.3 符号表和符号解析



### 4.4 重定位



### 4.5 动态链接

