---
title: SysBasic
categories:
  - GPA
  - 4th-term
category_bar: true
---

## 《计算机系统基础》

## 前言

学科地位：

| 主讲教师 | 学分配额 | 学科类别 |
| :------: | :------: | :------: |
|  闫文珠  |   3.5    |  专业课  |

成绩组成：

| 实验（9次） | 平时作业 | 期末（闭卷） |
| :---------: | :------: | :----------: |
|     20%     |   30%    |     50%      |

教材情况：

|    课程名称    |    选用教材    | 版次 |  作者  |     出版社     |      ISBN号       |
| :------------: | :------------: | :--: | :----: | :------------: | :---------------: |
| 计算机系统基础 | 计算机系统基础 |  4   | 袁春风 | 机械工业出版社 | 978-7-111-60489-1 |

学习资源：

- :tv: 视频资源：[袁春风](https://www.icourse163.org/u/mooc1463468641395)

期末考试：

- 简答（类似于作业）
- 计算（类似于作业）
- 综合（尽可能收集老师们的复习资料）

## 第1章 计算机系统概述

### 1.1 计算机基本工作原理

![冯.诺依曼结构 - 计算机模型](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202404141728836.png)

如图，冯诺依曼认为计算机应该由上述五个部分组成，相互协作完成任务：

1. 存储器：存储数据和指令
2. 运算器：可以进行四则运算和逻辑运算
3. 控制器：自动取指令来执行
4. 输入设备：用户输入
5. 输出设备：系统输出

现代计算机结构模型

![现代计算机结构模型](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202405141947181.png)

### 1.2 程序的开发与运行

pass

### 1.3 计算机系统的层次结构

![计算机系统的层次结构](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202404141733628.png)

### 1.4 计算机系统性能评价

一个完整的计算机系统由软件和硬件共同组成，而硬件的性能对其起决定性作用，但是硬件的性能检测和评价比较困难。本目介绍综合性测试、评价**硬件性能**的方法。

#### 1.4.1 计算机性能的定义

考量一个计算机性能的基本指标有两个，分别为吞吐率（throughput）和响应时间（response time），下面做出相应的理论解释和自己的理解。

理论定义

- 吞吐率：计算机系统单位时间内完成的工作量。

- 响应时间：计算机系统完成一个作业从提交开始到作业完成所用的时间。

{% fold light @个人理解 + 适合场景 %}

**个人理解**：我们以备份文件为例。**对于一个大文件**，我们希望计算机系统的吞吐率性能足够好，这样处理单文件的能力就会很高。**对于很多的小文件**，吞吐率高没有什么决定性作用，起决定性作用的是响应时间，我们希望响应时间尽可能的短，这样处理大规模小文件集合的时候就会有优势。那么相应的适用场景也就合理了。

**适用场景**：对于多媒体应用场景，就相当于大型文件，此时自然希望吞吐率尽可能的高。对于银行、证券交易业务，就相当于大规模小文件集合，我们希望系统的响应时间尽可能的短，这样就可以在单位时间解决更多的小型业务。当然，两者性能均优异自然是最佳选择，对于一些用户体验很重要的应用，比如 ATM、文件服务、Web 服务 等等，就需要两者性能均优。

{% endfold %}

#### 1.4.2 计算机性能的测试

如果不考虑应用背景而直接比较计算机性能，往往通过**程序的执行时间**来衡量。下附程序的执行时间组成图：

{% fold light @程序的执行时间组成图 %}

![程序的执行时间（用户感受到的）](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202403252043639.png)

{% endfold %}

我们关注的是**用户 CPU 时间**。那么如何计算呢？我们引入三个相关计算量：

1. 时钟周期：一个时钟脉冲信号持续的时间。由于计算机执行官一条指令得过程会被分为不同的小模块进行，因此我们需要控制每一个小模块的执行。于是引入脉冲信号来控制信号的发出、作用时间等。
2. 时钟频率：单位时间内的时钟周期数。即上述时钟周期的倒数。
3. CPI（Cycles Per Instruction）
    - 对于一条指令而言：CPI 指的是一条指令所需的时钟周期数
    - 对于一个程序或一台机器而言：CPI 指的是该程序或机器的指令集中所有指令平均执行所需的时钟周期数

计算**用户 CPU 时间**的公式：

$$
\begin{equation*}
\begin{aligned}
\text{用户 CPU 时间} 
&= \text{程序总时钟周期数} \times \text{时钟周期} \\
&= \text{程序总时钟周期数} \div \text{时钟频率}
\end{aligned}
\end{equation*}
$$
补充说明：

- 显然，用户 CPU 时间与计算机性能成反比
- 上述三个相关计算量是相互制约的，不存在只提升或下降某一个指标

#### 1.4.3 用指令执行速度进行性能评估

pass

#### 1.4.4 用基准程序进行性能评估

pass

#### 1.4.5 Amdahl 定律

对于系统中某个部分（软件或硬件）进行更新所带来的系统的性能提升，是取决于这部分原本的运行时间占总运行时间，以及这部分升级了多少倍两者共同决定的，用公式表示**改进后系统的执行时间**：
$$
\text{改进后的执行时间} = \frac{\text{改进部分原本占用的时间}}{\text{改进的倍数}}+\text{剩余部分占用的时间}
$$
当然**整体改进倍数**也就可以表示为：
$$
\text{整体改进倍数} = \frac{1}{ \frac{\text{改进部分原本占用的时间比例}}{\text{改进的倍数}} + \text{剩余部分占用的时间比例} }
$$

### 1.5 本书的主要内容与组织结构

第一章主要介绍：计算机的基本工作原理、计算机系统的基本组成、程序的开发与执行过程、计算机系统的层次结构以及性能评价的基本概念。

第二章主要介绍：各类数据在计算机中的表示与运算。

第三章主要介绍：高级语言中的过程调用和控制语句所对应的汇编指令序列，以及各类数据结构元素的访问所对应的汇编指令。

第四章主页介绍：如何将多个模块链接起来生成一个可执行的目标文件。

## 第2章 数据的机器级表示与处理

{% note light %}

本章主要从四个方面展开，分别为：数值数据的表示、非数值数据的表示、数据的存储、数据的运算。

{% endnote %}

### 2.1 数制和编码

#### 2.1.1 信息的二进制编码

- 计算机内部所有的信息都采用二进制 01 进行编码

- 需要编码的机器级数据分为以下两类：
    1. 数值数据：整数（带符号、无符号）、浮点数
    2. 非数值数据：逻辑数、西文字符、汉字字符
- 理解真值和机器数的概念

#### 2.1.2 进位计数制

进制表示

1. 二进制：后缀为 B（即 Binary，如 0110B）
2. 八进制：后缀为 O（即 Octal，如 12673O）
3. 十进制：后缀为 D（即 Decimal，如 291D；可省略，即 291）
4. 十六进制：后缀为 H（即 Hexadecimal，如 3F9H；可以前缀 0x 标记，即 0x3F9）

进制转换：一般先将数据转换为二进制，再进行相应转换

1. R 进制转换为 十 进制
2. 十进制转换为 R 进制
3. 二、八、十六进制的相互转换

#### 2.1.3 定点与浮点的表示

定点数：小数点位置约定在固定位置的数

- 定点小数：小数点总是固定在数的最左端，可以用来表示浮点数的尾数部分
- 定点整数：小数点总是固定在数的最右端，可以用来表示整数

浮点数：小数点位置约定为可浮动的数。对于任意一个实数 X 都可以表示成下面的形式：
$$
X = (-1)^{S} \times M \times R^E
$$

- $S$ 取 $0$ 或 $1$ 决定当前实数的正负
- $M$ 是一个二进制定点小数，称为实数的**尾数**。有效位数越多，说明精度越高
- $E$ 是一个二进制定点整数，称为实数的**阶数**。决定小数点的位置
- $R$ 称为实数的**基数**。由数制决定

取值范围：假定浮点数的尾数为纯小数即尾数不为零，则浮点数 $X$ 的绝对值的最小值表示为 $0.00...1 \times R^{-11...1}$，最大值表示为 $0.11...1 \times R^{11...1}$。假设阶的位数为 $m$，尾数的位数为 $n$。则浮点数 $X$ 的绝对值真值的取值范围为：
$$
R^{-n} \times R^{-(R^m-1)} \le |X| \le (1-R^{-n}) \times R^{R^m-1}
$$

#### 2.1.4 定点数的编码表示

1. 原码表示法
2. 补码表示法
    - 模运算：$\text{对一个负数取模} = \text{模} - |\text{负数}|$
    - 补码的定义：$[X]_{\text{补}}=2^n+X$，对于 $n$ 位的运算系统，可以表示补码的数据范围为 $-2^{n-1} \le X < 2^{n-1}$
3. 反码表示法
4. 移码表示法

### 2.2 整数的表示

#### 2.2.1 无符号整数和带符号整数的表示

无符号整数：所有的二进制位都用来表示数值。比如对于 $n$ 位的二进制数，无符号整数的数值范围为 $[0,2^{n} - 1]$

有符号整数：第一位二进制位必须用来进行正负性表示，后 $n-1$ 位用来表示数值。同样对于 $n$ 位的二进制数，有符号整数的数值范围为 $[-2^{n-1}, 2^{n-1})$

#### 2.2.2 C 语言中的整数及其相互转换

C 语言标准中规定：若运算中同时有无符号和带符号整数，则按无符号整数运算

搞懂这张真值比较表即可：

![真值比较表](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202404141849432.png)

### 2.3 浮点数的表示

#### 2.3.1 浮点数的表示范围

我们一以 32 位浮点数为例。32 位中：

- 第 0 位为符号位 $\text{(Sign)}$。1 表示负数，0 表示正数
- 第 1 - 8 位为阶数位 $\text{(Exponent)}$。采用移码表示，通常需要加上偏执常数 128
- 第 9 - 31 位为尾数位 $\text{(Fraction)}$。规格化尾数的表示形式为 $0.1\text{bb...b}$​

正数的最大值：$0.11...1 \times 2^{11...1}=(1-2^{-24}) \times 2^{127}$

正数的最小值：$0.10...0 \times 2^{00...0} = 2^{-1} \times 2^{-128}=2^{-129}$

![浮点数的表示范围](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202405052136266.png)

#### 2.3.2 浮点数的规格化

分为左规和右规，目的是尽可能多的得到有效位，同时使得浮点数的表示具有唯一性

#### 2.3.3 IEEE 754 浮点数标准

与前面提到的规则略有不同。对于下列两种精度的浮点数：有以下规定：

1. 对于尾数：隐藏位 1 还是存在，不过现在不是在小数点右边，而是在小数点左边
2. 对于阶数：同样采用移码的形式，只不过现在的偏执常数不是 $2^{n-1}$，而是 $2^{n-1}-1$。因此单精度和双精度浮点数的偏执常数分别为 $2^{8-1}-1=127,2^{11-1}-1=1023$

![IEEE 754 浮点数标准](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202405052143554.png)

对于本目，需要掌握 **IEEE 754 规格化小数**与**真值**之间的转换，转换规则如下：

{% fold light @转换规则 %}

![十进制小数转化为IEEE754的小数](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202404081030218.png)

![IEEE754小数转化为十进制小数](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202404081030753.png)

浮点数的 5 种表示形式：

![浮点数的5种表示形式](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202405111003712.png)

单精度浮点数的各种极端情况：

![单精度浮点数的各种极端情况](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202405111005676.png)

{% endfold %}

#### 2.3.4 C 语言中的浮点数类型

主要掌握强制类型转换。

- int 到 float 可能丢失有效数字。因为 int 的有效数位比 float 多
- int 和 float 到 double 数值不变
- double、float 到 int 可能丢失有效数字或溢出
- double 到 float 可能丢失有效数字或溢出

### 2.4 十进制数的表示

#### 2.4.1 用 ASCII 码字符表示

pass

#### 2.4.2 用 BCD 码表示

pass

### 2.5 非数值数据的编码表示

#### 2.5.1 逻辑值

1 个 二进制数表示 1 个逻辑值。

#### 2.5.2 西文字符

西文字符集的编码是 ACSII 码，一般是 7 位二进制位 $b_6b_5b_4b_3b_2b_1b_0$ 来表示。可能会有第八位 $b_7$，该位往往用来进行奇偶校验。

#### 2.5.3 汉字字符

汉字数量庞大，且是表意形的字符，为了在计算机中表示汉字，我们需要处理三个问题，分别是输入表示、机器表示、输出表示：

1. 汉字的输入码：用于对输入的中文字符进行编码

2. 字符集与汉字内码：用于系统内部的存储、查找、传送等处理

3. 汉字的字模点阵码和轮廓描述：用于显示和打印

概念定义：

  - 图像的基本单位是像素，是真实世界的数字表示

  - 图形的往往是数学或程序算法生成的，是虚构的


### 2.6 数据的宽度和存储

#### 2.6.1 数据的宽度和单位

计算机中数据的**表示宽度**及其单位

- 二进制信息的最小单位：比特（bit）

- 最小寻址单位：字节（Byte），其中 1Byte = 8 bit
- 更大的单位表示：字（word），其中 1 word = 2 bit | 4 bit | 8 bit | 16 bit

计算机中数据的运算、存储、传输的**部件宽度**及其单位

- 数据通路宽度：字长

#### 2.6.2 数据的存储和排列顺序

对于一个 32 bit 的数 `1000 0000 0000 0000 0000 0000 0000 0110` 而言，我们定义：

- 最高有效位（MSB，Most Significant Bit）：上述 32 位数的最左边的一位 `1`

- 最低有效位（LSB，Least Significant Bit）：上述 32 位数的最右边的一位 `0`

- 最高有效字节（MSB，Most Significant Byte）：上述 32 位数的最左边的一字节 `1000 0000`

- 最低有效字节（LSB，Least Significant Byte）：上述 32 位数的最右边的一字节 `0000 0110`

现代计算机都是对字节进行编址方式。由于程序中对每个数据只给定一个地址，那么对于多字节的数据如何根据仅有的一个地址进行 CPU 的内存分配呢？这就是经典的字节排序问题。现在介绍两种内存分配方式：大端方式、小端方式

- 大端方式：最低有效字节存放在最高位

- 小端方式：最低有效字节存放在最低位

- 举例说明：对于机器数 `FFFFFFF6` 而言，下面的表示方式中，左侧为小端存储，右侧为大端存储

    ![左侧为小端存储，右侧为大端存储](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202404081008751.png)

### 2.7 数据的基本运算

{% note light %}

学完了基本的数据表示以后，让我们开始学习数据的基本运算。高级语言中涉及到的各种运算，都会被编译成底层的算术运算指令和逻辑运算指令实现，本目要介绍的也就是其中的运算逻辑。

{% endnote %}

#### 2.7.1 按位运算和逻辑运算

按位运算

|   \|   |   &    |    ~     |    ^     |
| :----: | :----: | :------: | :------: |
| 按位或 | 按位于 | 按位取反 | 按位异或 |

逻辑运算

|  \|\|  |   &&   |   !    |
| :----: | :----: | :----: |
| 逻辑或 | 逻辑与 | 逻辑非 |

#### 2.7.2 左移运算和右移运算

无符号整数采用**逻辑移位**：

- 左移：高位移出，低位补 0。**如果移出为 1，则溢出**
- 右移：高位补 0，低位移出

有符号整数采用**算数移位**：

- 左移：高位移出，低位补 0。**如果左移前后符号位不同，则溢出**
- 右移：高位补符号，低位移出

#### 2.7.3 位扩展运算和位截断运算

扩展操作：在短数向长数转换时

- 有符号整数采用**符号扩展**：前方补符号位
- 无符号整数采用 **0 扩展**：前方补 0

{% fold light @code %}

```cpp
#include <stdio.h>

int main() {
    short int si = -32768;
    unsigned short usi = si;
    int i = si;
    unsigned ui = usi;
    
    printf("si  = \t%hd\t%x\n", si, si);
    printf("usi = \t%hu\t%x\n", usi, usi);
    printf("i   = \t%d\t%x\n", i, i);
    printf("ui  = \t%u\t%x\n", ui, ui);
}
```

上述代码在 32 位大端机器上的输出：

```
si  =   -32768  8000
usi =   32768   8000
i   =   -32768  ffff8000
ui  =   32768   8000
```

分析：

- `si` 和 `usi` 是同一个机器数的不同真值结果，由于数位没有长短的变化，故十六进制表示结果相同
- `i` 是有符号整数的位扩展，采用符号扩展，补充符号位 1，故向前补充了 16 个 1
- `ui` 是无符号数的位扩展，采用 0 扩展，补充 0，故向前补充了 16 个 0

{% endfold %}

截断操作：在长数向短数转换时

- 有符号整数，高位直接丢弃
- 无符号整数，高位直接丢弃

{% fold light @code %}

```cpp
#include <stdio.h>

int main() {
    int i = 32768;
    short si = (short)i;
    int j = si;

    printf("i  = \t%d\t%x\n", i, i);
    printf("si = \t%hd\t%x\n", si, si);
    printf("j  = \t%d\t%x\n", j, j);
}
```

上述代码在 32 位大端机器上的输出：

```
i  =    32768   00008000
si =    -32768  8000
j  =    -32768  ffff8000
```

分析：

- `i` 的真值和机器数很显然
- `si` 的机器数就是将 `i` 的机器数截取了后 16 位的结果，在识别为有符号数以后，得到的真值就是最小的负数 -32768
- `j` 是有符号整数的位扩展运算，补充符号位 1
- 可以发现了**截断错误**，而这种错误编译器一般是不会发现的！

{% endfold %}

#### 2.7.4 整数加减运算

![整数加/减运算部件](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202404081025914.png)

部件解读：对于无符号整数和有符号整数而言，都可采用该运算部件进行运算

- 输入：
    1. 运算数 A：整数 A 的补码 01 序列
    2. 运算数 B：整数 B 的补码 01 序列
    3. 判别数 Sub：`A+B` 时 `Sub=0`，`A-B` 时 `Sub=1`
    
- 输出：
    1. 结果 Sum：表示整数 `A+B` 的计算结果
    
    2. 零标志 ZF：表示 `A+B` 是否为 0
    
    3. 符号标志 SF：表示计算结果 Sum 的有效范围内的最高位二进制数值
    
    4. 溢出标志 OF：判断**有符号整数**的相加结果是否溢出。计算方式： 
    
        - 若 A 与 B' 首位同号且与 Sum 的首位不相同，则计算溢出，`OF = 1`
        - 反之则计算未溢出，`OF = 0`
    
    5. 进/借位标志 CF：判断**无符号整数**的相加结果是否溢出。计算方式：
    
        - 对于加法：此时的判别数 `Sub = 0`
    
            - 若有进位，即 `Cout = 1`，则对于当前加法器表示计算溢出，`CF = 1`
            - 若没有进位，即 `Cout = 0`，则没有计算溢出，`CF = 0`
    
        - 对于减法：此时的判别数 `Sub = 1`
    
            - 若有借位，则 `Cout = 0`，则对于当前加法器表示计算结果是负数，即计算溢出，`CF = 1`
            - 若没有借位，则 `Cout = 1`，则对于当前加法器表示计算结果是正数，即计算未溢出，`CF = 0`
    
        - 综上所述：
            $$
            \text{CF} = \text{Sub} \oplus \text{Cout}
            $$

{% fold light @举例说明 %}

对于两个机器数 `x = 1000 0110` 和 `y = 1111 0110`

加法：计算 `x + y`

$$
\begin{aligned}

&\text{MUX}:
\begin{cases}
y' &= y \\
\text{Sub} &= 0
\end{cases}

\\

&\text{Adder}:
\begin{cases}
x: & 1000\ 0110 \\
y'=y: & 1111\ 0110 \\
\text{Sub}: & 0
\end{cases}

\\

&\text{Result}: 1 \ 0111\ 1100

\\

&\text{Signals}:
\begin{cases}
\text{ZF} = 0 \\
\text{SF} = 0 \\
\text{OF} = 1 \\
\text{CF} = 1
\end{cases}

\\

&\text{Real Value}:
\begin{cases}
\text{signed}: &124(134+246-2^8)\\
\text{unsigned}: &124(134+246-2^8)
\end{cases}

\end{aligned}
$$
减法：计算 `x - y`
$$
\begin{aligned}

&\text{MUX}:
\begin{cases}
y' &= \overline{y} \\
\text{Sub} &= 1
\end{cases}

\\

&\text{Adder}:
\begin{cases}
x: & 1000\ 0110 \\
y'=\overline{y}: & 0000\ 1001 \\
\text{Sub}: & 1
\end{cases}

\\

&\text{Result}: 0 \ 1001\ 0000

\\

&\text{Signals}:
\begin{cases}
\text{ZF} = 0 \\
\text{SF} = 0 \\
\text{OF} = 0 \\
\text{CF} = 1
\end{cases}

\\

&\text{Real Value}:
\begin{cases}
\text{signed}: &-112 \\
\text{unsigned}: &144(134-246+2^8)
\end{cases}

\end{aligned}
$$
对于 n=8 的情况而言，数据范围是：
$$
\begin{cases}
\text{signed}: &[-2^{n-1},2^{n-1} - 1] &=& [-128,127] \\
\text{unsigned}: &[0,2^n - 1] &=& [0,255]
\end{cases}
$$
{% endfold %}

#### 2.7.5 整数乘除运算

**整数乘法中**。两个 n 位的整数相乘得到一个 2n 位整数，但是一般只保留低 n 位，高 n 位舍弃。**判断乘法溢出**规则如下：

- 对于无符号整数乘法：若高 n 位全 0 则没溢出，反之溢出
- 对于有符号整数乘法：若高 n 位全等于 低 n 位的首尾，则没溢出，反之溢出

**整数除法中**。两个 n 位整数相除，**溢出异常和小数舍去**规则如下：

- 除了最小负数除以 -1 会发生溢出，以及除 0 会发生异常以外，其余情况全部是正常运算
- 无论是带符号还是无符号，所有产生的小数部分全部舍弃，效果就是向 0 取整


#### 2.7.6 常量的乘除运算

**常量乘法运算中**。由于直接当做整数进行乘法会导致更高的消耗，因此编译器一般会将其拆分为移位运算与加减运算的综合运算

- 比如表达式 `x * 20` 中的 20 会被二进制拼凑分解为 `2^4 + 2^2`，也就是将 x 左移 4 位的结果与 x 左移 2 位的结果相加

**常量除法运算中**。同样由于时间开销极大，也是采用移位进行优化，但是与加法略有不同，对于除数是一个 $2^k$ 整数的形式时：

1. 若被除数是**无符号数**或者**有符号正数**，直接低位丢弃，高位按照相应的规则补齐
2. 若被除数是**有符号负数**，且移出低位时有 1，则需要先将被除数加上 $2^k-1$，再执行第一步的操作

#### 2.7.7 浮点数运算

以浮点数加减为例。

- 转换：转换为二进制数
- 对阶：小阶往大阶靠拢
- 尾数加减
- 尾数规格化：只能让 1 出现在小数点的左边一位
- 阶码溢出判断

## 第3章 程序的转换及机器级表示 TODO

{% note light %}

计算机的指令有微指令、机器指令、伪（宏）指令，其中微指令是硬件层面、伪指令是软件层面，而机器指令介于两者之间，是用来进行硬件和软件的交互的。本章主要介绍的就是 C 语言程序与 IA-32 机器级指令之间的对应关系。

{% endnote %}

### 3.1 程序转换概述 

#### 3.1.1 机器指令及汇编指令

计算机只认识机器指令，但是机器指令只是一个 01 位串，可读性很差，因此引入汇编指令用于助记。由机器指令组成的程序叫机器语言程序，由汇编指令组成的程序叫汇编语言程序。机器语言程序和汇编语言程序都是机器级程序。将汇编语言转化为机器语言的程序叫**汇编程序**，将机器语言转化为汇编语言的程序叫**反汇编程序**。

但是汇编语言程序还是很抽象，因此引入高级语言程序。现在我们要解决的是如何将高级语言程序转化为机器语言程序。至于如何转化的时间、空间都最优，这是编译优化要解决的事。

#### 3.1.2 指令集体系结构

会看 1.3 节可以发现，指令集体系结构 $\text{(Instruction Set Architecture，简称 ISA)}$ 是连接计算机硬件和软件之间的桥梁，将物理上的计算机硬件抽象成了逻辑上的虚拟计算机，称为机器语言级虚拟机。

ISA 定义了机器语言级虚拟机的所有功能。

#### 3.1.3 生成机器代码的过程

本目介绍高级语言转化为机器语言的过程，以 C 语言该高级语言为例。假设当前有一个 C 语言文件 `main.c`，利用 gcc 工具可以实现。

1. **预处理**：在源程序中插入所有用 `#include` 命令指定的文件和用 `#define` 声明指定的宏。生成的 `main.i` 是**文本文件**

    ```bash
    gcc -E main.c -o main.i
    ```

2. **编译**：将预处理后的源程序编译成汇编语言程序。生成的 `main.s` 是**文本文件**

    ```bash
    gcc -S main.i -o main.s
    ```

3. **汇编**：通过汇编程序将编译出来的汇编语言程序转化为可重定位的机器语言程序。生成的 `main.o` 是**二进制文件**

    ```bash
    gcc -c main.s -o main.o
    ```

4. **链接**：将多个可重定位的机器语言程序以及库程序链接为可执行文件

    ```bash
    gcc main.o -o main
    ```

上述第三步汇编出来的二进制文件 `main.o` 是不可读的，但是我们可以通过将其反汇编成文本文件，进而可读。可以采用 objdump 工具，通过 -d 参数命令将其反汇编为由汇编语言构成的文本文件，命令如下：

```bash
objdump -d main
```

需要补充的一点是：本书中的汇编语言程序的格式采用 $\text{AT\&T}$，这也是 gcc 和 objdump 使用的默认汇编格式。

### 3.2 IA-32 指令系统概述

IA-32 即 x86-32

#### 3.2.1 数据类型及其格式

IA-32 支持的数据类型及格式与 C 语言之间的对应关系

![IA-32 支持的数据类型及格式与 C 语言之间的对应关系](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202405212015803.png)

#### 3.2.2 寄存器组织和寻址方式

三类操作数：立即数、寄存器操作数、存储器操作数。立即数就保存在指令中，不予讨论。

寻址方式：根据指令给定的信息得到操作数或操作数地址

- 操作数所在位置：
    1. 指令中：立即寻址
    2. 寄存器中：寄存器寻址
    3. 存储器中 (内存 or 磁盘)：存储器寻址
    
- 保护模式下的寻址方式：
    1. 立即寻址：指令直接给出操作数
    
    2. 寄存器寻址：指定寄存器 R 的内容为操作数
    
    3. **存储器寻址：基址 + 变址 × 比例因子 + 偏移地址**
    
        ![示例 - AT&T格式汇编](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202405212043567.png)

#### 3.2.3 机器指令格式

查表

### 3.3 IA-32 常用指令类型及其操作 TODO

#### 3.3.1 传送指令

#### 3.3.2 定点算数运算指令

#### 3.3.3 按位运算指令

#### 3.3.4 控制转移指令

### 3.4 C 语言程序的机器级表示 TODO

{% note light %}

用任何汇编语言或高级语言编写的**源程序**都必须**翻译**（汇编、解释或编译）成以指令形式表示的**机器语言**，才能在计算机上运行。本节高级语言选用 **C 语言**，机器语言选用 **IA-32 指令系统**，简单介绍高级语言转化为机器语言的过程。

{% endnote %}

#### 3.4.1 过程调用的机器级表示 :star:  TODO

本目讲解不同模块之间的调用接口约定。由于 C 语言中，程序的过程性体现在函数中，因此我们用函数来表示过程。

1. **IA-32 中用于过程调用的指令**

    CALL 调用指令：在执行调用过程之前需要将返回地址压入栈

    RET 返回指令：在返回调用过程之前从栈中取出返回地址

2. **过程调用的执行步骤**（记调用者为 P，被调用者为 Q）

    |                          步骤                          |                       过程                       |
    | :----------------------------------------------------: | :----------------------------------------------: |
    |           P 将参数存储到 Q 可以访问到的地方            |           按参数列表从右往左依次压入栈           |
    | P 保存返回地址（即调用函数的下一个语句）并将控制权给 P |                  通过 CALL 指令                  |
    |      Q 保存 P 的现场并为自己的非静态变量分配空间       | 一般由调用与被调用过程共同保存通用寄存器中的现场 |
    |                    执行 Q 的函数体                     |                       ---                        |
    |           Q 恢复 P 的现场并释放局部变量空间            |            恢复现场并释放局部变量空间            |
    |              Q 取出返回地址并将控制权给 P              |                  通过 RET 指令                   |

3. **过程调用所使用的栈**

    从上述调用过程来看，我们需要至少需要保存以下数据：入口参数、返回地址、调用过程执行时用到的寄存器、被调用过程中的非静态局部变量、过程返回的结果。最好就是直接存储到寄存器中，但现在的问题是用户可见寄存器的数量有限并且所有过程使用的寄存器是共享的，因此我们不能直接存储到寄存器中。因此我们才用 **栈(stack)** 结构来存储这些数据

4. 

#### 3.4.2 选择语句的机器级表示 TODO



#### 3.4.3 循环语句的机器级表示 TODO



### 3.5 复杂数据类型的分配和访问 TODO

#### 3.5.1 数组的分配与访问 TODO

#### 3.5.2 结构体数据的分配与访问

采用首地址+偏移的逻辑分配与访问数据。一个结构体存储所有字段的数据。

#### 3.5.3 联合体数据的分配与访问

同样采用首地址+偏移的逻辑分配和访问数据。一个在同一时刻只存储一种数据类型。即相同的位序列可以在不同时刻存储不同的数据类型变量。

#### 3.5.4 数据的对齐

对于 32 位 OS 而言，存储器一行存储 32 位共 4 个字节，计算机系统一次访问存储空间只能读写固定长度的位。假定最多可以读写 64 位，则称为 8 字节宽的存储器机制。一般采用**按边界对齐**的对齐策略。按边界对齐会浪费一些存储空间，但是有利于数据的访问。

{% fold light @举两个例子%}

一、对齐实例。对于 5 个变量 `int a; short b; double c; char d; short e;`

按边界对齐：

![按边界对齐](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202405131154702.png)

边界不对齐

![边界不对齐](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202405131154636.png)

二、结构体实例。全部按 4 字节对齐，末尾可能有插空

```cpp
struct A {
    int    i;
    short si;
    char   c;
    double d;
};
```

![1](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202405131238885.png)

```cpp
struct B {
    int    i;
    short si;
    double d;
    char   c;
};
```

![2](https://dwj-oss.oss-cn-nanjing.aliyuncs.com/images/202405131239595.png)

{% endfold %}

### 3.6 越界访问和缓冲区溢出 TODO



## 第4章 程序的链接

{% note light %}

在编写大型程序时，往往需要分开进行编写，这就需要我们对多个分散的源代码片段进行组合。目前的组合方法是：首先对每一个部分分开进行编译和汇编生成对应的目标代码文件，然后通过链接器（linker）将所有的目标代码文件与使用到的其他库的目标代码文件结合，形成最终的可执行文件。本章主要讲解链接器的工作原理。

{% endnote %}

### 4.1 编译、汇编和静态链接



### 4.2 目标文件格式



### 4.3 符号表和符号解析



### 4.4 重定位



### 4.5 动态链接

